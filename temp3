def generate_charts_custom2(user_query: str, sql_query: str) -> list:
    """
    Same as before, but:
      - Any column with ‚â§10 unique values can be used for grouping.
      - No per-chart print() noise.
    """
    try:
        # fetch latest CSV from Azure
        azure = AzureStorage()
        container = azure.client.get_container_client(AZURE_CONFIG["container"])
        blobs = sorted(
            container.list_blobs(name_starts_with=f"{AZURE_CONFIG['results_folder']}/"),
            key=lambda b: b.creation_time, reverse=True
        )
        if not blobs:
            print("‚ùå No data available for chart generation.")
            return []
        df = pd.read_csv(BytesIO(container.download_blob(blobs[0].name).readall()))
        if df.empty:
            print("‚ö†Ô∏è The latest dataset is empty. No charts can be generated.")
            return []

        # sample & stats
        sample_df = df.sample(min(100, len(df)), random_state=42)
        sample_md  = sample_df.to_markdown(index=False)
        stats_md   = df.describe(include='all').to_markdown()

        # column roles
        col_roles = {
            col: ("date" if pd.api.types.is_datetime64_any_dtype(df[col])
                  else "numeric" if pd.api.types.is_numeric_dtype(df[col])
                  else "categorical")
            for col in df.columns
        }

        # build & send prompt (unchanged) ‚Ä¶
        prompt = f"""‚Ä¶"""  # same as before
        ai = AIService()
        resp = ai.client.chat.completions.create(
            model=OPENAI_CONFIG["deployment"],
            messages=[{"role":"user","content":prompt}],
            temperature=0.3,
            max_tokens=800
        )
        text = resp.choices[0].message.content.strip()

        # extract JSON
        try:
            match = re.search(r"\{.*\}", text, re.DOTALL)
            chart_json = json.loads(match.group(0)) if match else {}
        except:
            chart_json = {}

        charts = chart_json.get("charts", [])
        figs   = []
        seen   = set()

        def is_numeric(col):
            return pd.api.types.is_numeric_dtype(df[col])

        # pick first small‚Äêcardinality column that's not x or y
        def pick_group(df, x, y):
            for col in df.columns:
                if col in (x, y): continue
                if df[col].nunique() <= 10:
                    return col
            return None

        for ch in charts:
            c, x, y, z = ch.get("type"), ch.get("x"), ch.get("y"), ch.get("z")
            if not all([c, x, y]) or (c, x, y) in seen:
                continue
            if x not in df or y not in df:
                continue
            if c == "pie" and df[x].nunique() > 10:
                continue
            if c == "line" and not (pd.api.types.is_datetime64_any_dtype(df[x]) or is_numeric(x)):
                continue
            if c in ["bar","line","scatter","heatmap","treemap","pie"] and not is_numeric(y):
                continue

            seen.add((c, x, y))
            title = ch.get("reason", f"{c} of {y} vs {x}")

            # build each chart
            df_plot = df.copy()
            if c == "bar":
                fig = px.bar(df_plot, x=x, y=y, title=title)
            elif c == "scatter":
                fig = px.scatter(df_plot, x=x, y=y, title=title)
            elif c == "pie":
                fig = px.pie(df_plot, names=x, values=y, title=title)
            elif c == "treemap":
                path = [p for p in (x, z) if p in df_plot]
                fig = px.treemap(df_plot, path=path, values=y, title=title)
            elif c == "heatmap":
                fig = px.density_heatmap(df_plot, x=x, y=y, z=z if z in df_plot else None, title=title)
            elif c == "line":
                df_line = df_plot.sort_values(by=x)
                color = pick_group(df_line, x, y)
                if color:
                    fig = px.line(df_line, x=x, y=y, color=color, markers=True,
                                  title=f"{title} (grouped by {color})")
                else:
                    fig = px.line(df_line, x=x, y=y, markers=True, title=title)
            else:
                continue

            # scroll/pan config
            fig.update_layout(
                dragmode='pan',
                autosize=False,
                width=min(max(150*len(df_plot.columns),800),2000),
                height=600,
                margin=dict(l=20,r=20,t=30,b=20),
                xaxis=dict(fixedrange=False, rangeslider=dict(visible=True)),
                yaxis=dict(fixedrange=False)
            )
            fig.show(config={'scrollZoom':True,'displayModeBar':True})
            figs.append(fig)

        # fallback histograms
        if not figs:
            nums = [c for c in df.columns if is_numeric(c)]
            for col in nums[:3]:
                fig = px.histogram(df, x=col, title=f"Distribution of {col}")
                fig.update_layout(dragmode='pan', autosize=False,
                                  width=1000, height=600,
                                  xaxis=dict(fixedrange=False),
                                  yaxis=dict(fixedrange=False))
                fig.show(config={'scrollZoom':True})
                figs.append(fig)

        return figs

    except Exception as e:
        print(f"üî• Chart generation error: {e}")
        return []
